import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import { execSync } from "node:child_process";
import { mkdir, writeFile, readdir, readFile } from "node:fs/promises";
import { join } from "node:path";
import { rmSync, existsSync } from "node:fs";

const TEST_DIR = join(import.meta.dirname, "../..", ".test-pre-commit-pipeline");
const PACKAGES_DIR = join(TEST_DIR, "packages");
const WORKFLOWS_DIR = join(TEST_DIR, ".github", "workflows");
const TEMPLATES_DIR = join(TEST_DIR, "templates");

async function setupTestEnvironment(): Promise<void> {
  // Clean up
  if (existsSync(TEST_DIR)) {
    rmSync(TEST_DIR, { recursive: true, force: true });
  }

  // Create directory structure
  await mkdir(PACKAGES_DIR, { recursive: true });
  await mkdir(WORKFLOWS_DIR, { recursive: true });
  await mkdir(TEMPLATES_DIR, { recursive: true });

  // Copy workflow template
  const realTemplate = join(import.meta.dirname, "../../templates/workflow.template.yml");
  if (existsSync(realTemplate)) {
    const templateContent = await readFile(realTemplate, "utf-8");
    await writeFile(join(TEMPLATES_DIR, "workflow.template.yml"), templateContent);
  }
}

async function teardownTestEnvironment(): Promise<void> {
  if (existsSync(TEST_DIR)) {
    rmSync(TEST_DIR, { recursive: true, force: true });
  }
}

async function createTestPackage(
  name: string,
  options: { hasConfig?: boolean; configContent?: string } = {},
): Promise<void> {
  const pkgDir = join(PACKAGES_DIR, name);
  await mkdir(pkgDir, { recursive: true });

  // Create minimal package.json
  const packageJson = {
    name: `@embark/${name}`,
    version: "0.0.1",
    type: "module",
    scripts: { build: "echo building", dev: "echo dev" },
  };
  await writeFile(join(pkgDir, "package.json"), JSON.stringify(packageJson, null, 2));

  // Create src directory
  await mkdir(join(pkgDir, "src"), { recursive: true });
  await writeFile(join(pkgDir, "src", "index.ts"), "export const app = 'test';");

  // Create config if needed
  if (options.hasConfig) {
    const configContent =
      options.configContent || JSON.stringify({ deploy: "cloud-run" }, null, 2);
    await writeFile(
      join(pkgDir, ".embark.jsonc"),
      `// This file is auto-generated by Embark. Do not remove or edit manually.\n// Your deploy configuration is maintained here.\n${configContent}\n`,
    );
  }
}

async function countFiles(dir: string, pattern?: string | RegExp): Promise<number> {
  if (!existsSync(dir)) return 0;
  const files = await readdir(dir);
  if (!pattern) return files.length;
  return files.filter((f) => f.match(pattern)).length;
}

describe("pre-commit-pipeline", () => {
  describe("full pipeline simulation", () => {
    beforeEach(setupTestEnvironment);
    afterEach(teardownTestEnvironment);

    it("should execute scripts in correct order for new package", async () => {
      // Create a new package without config
      await createTestPackage("test-app", { hasConfig: false });

      // Verify initial state
      expect(await countFiles(PACKAGES_DIR)).toBe(1);
      expect(await countFiles(WORKFLOWS_DIR, /\.yml$/)).toBe(0);

      // Simulate pipeline by running scripts individually
      // In real hook, they all run sequentially

      // 1. ensure-deploy-config would create .embark.jsonc (skipped - interactive)
      // For testing, we create it manually to simulate user choice
      const pkgDir = join(PACKAGES_DIR, "test-app");
      const configContent = `// This file is auto-generated by Embark. Do not remove or edit manually.
// Your deploy configuration is maintained here.
{
  "deploy": "cloud-run"
}
`;
      await writeFile(join(pkgDir, ".embark.jsonc"), configContent);

      // 2. Verify config was created
      expect(existsSync(join(pkgDir, ".embark.jsonc"))).toBe(true);

      // 3. Config should be readable
      const configFile = await readFile(join(pkgDir, ".embark.jsonc"), "utf-8");
      expect(configFile).toContain("auto-generated by Embark");
      expect(configFile).toContain('"deploy": "cloud-run"');
    });

    it("should handle multiple packages with different deploy targets", async () => {
      // Create packages with different targets
      await createTestPackage("cloud-app", { hasConfig: true });
      await createTestPackage("netlify-app", {
        hasConfig: true,
        configContent: JSON.stringify({ deploy: "netlify" }, null, 2),
      });
      await createTestPackage("custom-app", {
        hasConfig: true,
        configContent: JSON.stringify({ deploy: "other" }, null, 2),
      });

      // Verify all configs exist
      const pkgs = await readdir(PACKAGES_DIR);
      expect(pkgs).toHaveLength(3);

      for (const pkg of pkgs) {
        const configPath = join(PACKAGES_DIR, pkg, ".embark.jsonc");
        expect(existsSync(configPath)).toBe(true);
      }
    });

    it("should preserve existing configs during pipeline", async () => {
      await createTestPackage("preserved-app", { hasConfig: true });

      const configPath = join(PACKAGES_DIR, "preserved-app", ".embark.jsonc");
      const originalContent = await readFile(configPath, "utf-8");

      // Simulate pipeline running (scripts shouldn't modify existing configs)
      const currentContent = await readFile(configPath, "utf-8");

      expect(currentContent).toBe(originalContent);
      expect(currentContent).toContain('"deploy": "cloud-run"');
    });

    it("should create jsonc files with proper format", async () => {
      await createTestPackage("format-test", { hasConfig: false });
      const pkgDir = join(PACKAGES_DIR, "format-test");

      // Create config with comments
      const configWithComments = `// This file is auto-generated by Embark. Do not remove or edit manually.
// Your deploy configuration is maintained here.
{
  "deploy": "netlify"  // External deployment
}
`;
      await writeFile(join(pkgDir, ".embark.jsonc"), configWithComments);

      // Verify comments are present
      const content = await readFile(join(pkgDir, ".embark.jsonc"), "utf-8");
      expect(content).toContain("//");
      expect(content).toContain("auto-generated");

      // Verify JSON is still valid when comments are stripped
      const withoutComments = content.replace(/\/\/.*$/gm, "").replace(/\/\*[\s\S]*?\*\//g, "");
      const parsed = JSON.parse(withoutComments);
      expect(parsed.deploy).toBe("netlify");
    });

    it("should handle external deploy targets (no workflows)", async () => {
      await createTestPackage("netlify-site", {
        hasConfig: true,
        configContent: JSON.stringify({ deploy: "netlify" }, null, 2),
      });

      const config = await readFile(
        join(PACKAGES_DIR, "netlify-site", ".embark.jsonc"),
        "utf-8",
      );
      const parsed = JSON.parse(config.replace(/\/\/.*$/gm, ""));

      // Netlify packages should not generate workflows
      expect(parsed.deploy).toBe("netlify");

      // No workflow should be created
      expect(await countFiles(WORKFLOWS_DIR, /netlify-site\.yml$/)).toBe(0);
    });

    it("should create config files in correct location", async () => {
      await createTestPackage("location-test", { hasConfig: false });
      const pkgDir = join(PACKAGES_DIR, "location-test");

      // Config should be directly in package directory
      const configPath = join(pkgDir, ".embark.jsonc");
      await writeFile(
        configPath,
        `// auto-generated\n${JSON.stringify({ deploy: "cloud-run" }, null, 2)}\n`,
      );

      expect(existsSync(configPath)).toBe(true);

      // Not in src or other subdirs
      expect(existsSync(join(pkgDir, "src", ".embark.jsonc"))).toBe(false);
    });

    it("should maintain proper comment header format", async () => {
      await createTestPackage("header-test", { hasConfig: false });
      const pkgDir = join(PACKAGES_DIR, "header-test");

      const expectedHeader = `// This file is auto-generated by Embark. Do not remove or edit manually.
// Your deploy configuration is maintained here.`;

      const configContent = `${expectedHeader}
${JSON.stringify({ deploy: "cloud-run" }, null, 2)}
`;

      await writeFile(join(pkgDir, ".embark.jsonc"), configContent);

      const content = await readFile(join(pkgDir, ".embark.jsonc"), "utf-8");
      expect(content.startsWith(expectedHeader)).toBe(true);
      expect(content).toContain('"deploy": "cloud-run"');
    });
  });

  describe("config file validation", () => {
    beforeEach(setupTestEnvironment);
    afterEach(teardownTestEnvironment);

    it("should validate deploy target values", async () => {
      const validTargets = ["cloud-run", "netlify", "other"];

      for (const target of validTargets) {
        await createTestPackage(`app-${target}`, {
          hasConfig: true,
          configContent: JSON.stringify({ deploy: target }, null, 2),
        });

        const configPath = join(PACKAGES_DIR, `app-${target}`, ".embark.jsonc");
        const content = await readFile(configPath, "utf-8");
        const parsed = JSON.parse(content.replace(/\/\/.*$/gm, ""));

        expect(parsed.deploy).toBe(target);
      }
    });

    it("should handle missing or invalid config gracefully", async () => {
      await createTestPackage("no-config-app", { hasConfig: false });

      const pkgDir = join(PACKAGES_DIR, "no-config-app");
      const configPath = join(pkgDir, ".embark.jsonc");

      // File should not exist initially
      expect(existsSync(configPath)).toBe(false);
    });
  });
});
